```js
console.log('script start')

setTimeout(function () {
	console.log('setTimeout')
}, 0)

Promise.resolve()
	.then(function () {
		console.log('promise1')
	})
	.then(function () {
		console.log('promise2')
	})

console.log('script end')
```

script start => script end => promise1 => promise2 => setTimeout

## 任务执行顺序图示

Tasks 任务队列
microtasks 微任务队列
js stack js 调用栈
log 控制台输出

 <iframe  
 height=500
 src="https://azhen98.github.io/A-week-to-learn/index.html"  
 frameborder=0  
 allowfullscreen>
 </iframe>

 任务执行顺序

 同步代码按照顺序执行, 遇到异步代码, 等待延时结束将回调函数放入任务队列等待执行(这个任务队列相当于一个新的任务队列，也就是说需要等待当前的执行队列被清空之后才会执行), 继续执行,如果遇到微任务将其放到微任务队列, 继续执行, 同步代码执行完毕之后,开始执行微任务，微任务逻辑添加了新的微任务，所以这个新的微任务也会被执行，等待微任务执行完成之后，开始执行下一个任务队列

## 普通任务

产生条件

script 全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有 IE10 支持，具体可见 MDN）、I/O、UI Rendering

## 微任务

产生条件

```js
Process.nextTick //（Node独有）
Promise
Object.observe //废弃)
MutationObserver
```

解释

当任务队列执行结束之后会进入微任务执行队列，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务，也就是说一个微任务在执行的过程中添加一个新的微任务进入微任务队列，那么当前事件循环将继续执行新添加的微任务, 直到当前队列执行完成并且不再有新的微任务被添加进来。

执行主任务

![20210913164618](https://cdn.jsdelivr.net/gh/azhen98/A-week-to-learn@assert/image/20210913164618.png)

主任务执行过程中创建了新的 任务和微任务，现在执行微任务

![20210913164720](https://cdn.jsdelivr.net/gh/azhen98/A-week-to-learn@assert/image/20210913164720.png)

微任务执行完成后， 开始重新执行任务队列

![20210913164806](https://cdn.jsdelivr.net/gh/azhen98/A-week-to-learn@assert/image/20210913164806.png)